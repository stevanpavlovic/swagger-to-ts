import prettier from 'prettier';
import {
  descriptionToComment,
  findRef,
  pascalCase,
  tsArrayOf,
  tsMapOf,
  tsUnionOf,
} from '../utils/index';
import { OpenAPI2, OpenAPI2SchemaObject, Property } from '../types/index';

export const PRETTIER_OPTIONS: prettier.Options = { parser: 'typescript', singleQuote: true };

export const PRIMITIVES: { [key: string]: 'boolean' | 'string' | 'number' } = {
  // boolean types
  boolean: 'boolean',

  // string types
  binary: 'string',
  byte: 'string',
  date: 'string',
  dateTime: 'string',
  password: 'string',
  string: 'string',

  // number types
  double: 'number',
  float: 'number',
  integer: 'number',
  number: 'number',
};

export const WARNING_MESSAGE = `/**
 * This file was auto-generated by swagger-to-ts.
 * Do not make direct changes to the file.
 */
`;

export default function generateTypesV2(
  schema: OpenAPI2,
  propertyMapper?: (schemaObject: OpenAPI2SchemaObject, property: Property) => Property
): string {
  const output: string[] = []; // the final output (array representing lines of code)
  const queue: { name: string; schemaObject: OpenAPI2SchemaObject }[] = []; // processing queue

  if (!schema.definitions) {
    throw new Error(`no definitions in schema`);
  }

  /**
   * Get Schema Object type, following $refs
   */
  function typeScriptType({
    name,
    schemaObject,
  }: {
    name: string;
    schemaObject: OpenAPI2SchemaObject;
  }): string {
    const interfaceName = pascalCase(schemaObject.title || name); // use title if available

    const DEFAULT_TYPE = 'object';

    // type: $ref
    if (schemaObject.$ref) {
      const ref = findRef(schemaObject.$ref, schema);

      // handle arrays
      if (ref.ref.items && ref.ref.items.$ref) {
        return typeScriptType({ name: ref.name, schemaObject: ref.ref });
      }

      // if object, return object
      return ref.name || DEFAULT_TYPE;
    }

    // type: array
    if (schemaObject.items) {
      // if $ref present, use that
      if (schemaObject.items.$ref) {
        const ref = findRef(schemaObject.items.$ref, schema);
        return tsArrayOf(typeScriptType({ name: ref.name, schemaObject: ref.ref }));
      }

      // handle primitive
      if (schemaObject.items.type && PRIMITIVES[schemaObject.items.type]) {
        return tsArrayOf(PRIMITIVES[schemaObject.items.type]);
      }

      // handle shallow arrays
      if (schemaObject.items.type === 'array') {
        return tsArrayOf(typeScriptType({ name, schemaObject: schemaObject.items }));
      }

      // handle array of other interfaces
      queue.push({ name: interfaceName, schemaObject: schemaObject.items });
      return tsArrayOf(interfaceName);
    }

    if (Array.isArray(schemaObject.oneOf)) {
      return tsUnionOf(
        schemaObject.oneOf.map((def): string => typeScriptType({ name: '', schemaObject: def }))
      );
    }

    // type: object
    if (schemaObject.properties) {
      queue.push({ name: interfaceName, schemaObject: schemaObject.properties });
      return interfaceName;
    }

    // type: primitive or unknown
    if (schemaObject.type) {
      return PRIMITIVES[schemaObject.type] || schemaObject.type || DEFAULT_TYPE;
    }

    // type: null (return 'object')
    return DEFAULT_TYPE;
  }

  function handleAdditionalProperties(
    additionalProperties: boolean | OpenAPI2SchemaObject
  ): string {
    if ((additionalProperties as OpenAPI2SchemaObject).type) {
      const interfaceType = typeScriptType({
        name: '',
        schemaObject: additionalProperties as OpenAPI2SchemaObject,
      });
      return tsMapOf(interfaceType);
    }

    return tsMapOf('any');
  }

  function buildNextType(): void {
    const next = queue.pop();
    if (!next) return;
    const name = next.schemaObject.title || next.name;
    const { schemaObject } = next;

    // handle non-objects
    if (!schemaObject.$ref && schemaObject.type && schemaObject.type !== 'object') {
      output.push(`export type ${name} = ${typeScriptType({ name, schemaObject })};`);
      return;
    }

    let properties = schemaObject.properties || {};
    const includes: string[] = [];

    // include allOf, if specified
    if (Array.isArray(schemaObject.allOf)) {
      schemaObject.allOf.forEach((item): void => {
        // Add “implements“ if this references other items
        if (item.$ref) {
          const ref = findRef(item.$ref, schema);
          includes.push(ref.name);
        } else if (item.properties) {
          properties = { ...properties, ...item.properties };
        }
      });
    }

    // if nothing’s here, skip
    if (
      !Object.keys(properties).length &&
      schemaObject.additionalProperties !== true &&
      schemaObject.type &&
      PRIMITIVES[schemaObject.type]
    ) {
      return;
    }

    // open type
    const isExtending = includes.length ? ` extends ${includes.join(', ')}` : '';
    output.push(`export interface ${pascalCase(name)}${isExtending} {`);

    // Populate interface
    Object.entries(properties).forEach(([propertyName, propertyValue]): void => {
      const newID = pascalCase(`${name}-${propertyName}`);
      const interfaceType = Array.isArray(propertyValue.enum)
        ? ` ${tsUnionOf(propertyValue.enum.map((option) => JSON.stringify(option)))}` // Handle enums in the same definition
        : typeScriptType({ name: newID, schemaObject: propertyValue });

      let property: Property = {
        interfaceType,
        optional:
          !Array.isArray(schemaObject.required) ||
          schemaObject.required.indexOf(propertyName) === -1,
        description: schemaObject.description,
      };
      property = propertyMapper ? propertyMapper(schemaObject, property) : property;

      const interfaceKey = `"${propertyName}"${property.optional ? '?' : ''}`;

      // add JSDoc comments
      if (property.description) {
        output.push(descriptionToComment(property.description));
      }

      if (schemaObject.additionalProperties) {
        output.push(
          `${interfaceKey}: { ${handleAdditionalProperties(schemaObject.additionalProperties)} }`
        );
      } else {
        output.push(`${interfaceKey}: ${interfaceType};`);
      }
    });

    if (schemaObject.additionalProperties) {
      output.push(handleAdditionalProperties(schemaObject.additionalProperties));
    }

    // close interface
    output.push('}');
  }

  // start with definitions
  Object.entries(schema.definitions).forEach(([name, schemaObject]) => {
    queue.push({ name, schemaObject });
  });
  queue.sort((a, b) => a.name.localeCompare(b.name)); // sort initial definitions alphabetically

  // main loop: iterate over queue
  while (queue.length > 0) {
    buildNextType();
  }

  return prettier.format(output.join('\n'), PRETTIER_OPTIONS);
}
